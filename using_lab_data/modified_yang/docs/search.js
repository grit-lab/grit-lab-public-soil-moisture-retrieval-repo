window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "anc_functions", "modulename": "anc_functions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "anc_functions.get_L_eps_data", "modulename": "anc_functions", "qualname": "get_L_eps_data", "kind": "function", "doc": "<p>Read data from csv file.</p>\n\n<p>Args:\n    csv_file (str): path to the csv file.</p>\n\n<p>Returns:\n    numpy.ndarray: the data read from the csv file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "anc_functions.get_smc_data", "modulename": "anc_functions", "qualname": "get_smc_data", "kind": "function", "doc": "<p>Read Soil Moisture Content (SMC) data from csv file.</p>\n\n<p>Args:\n    csv_file (str): path to the csv file.</p>\n\n<p>Returns:\n    numpy.ndarray: the SMC data read from the csv file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "anc_functions.squared_error", "modulename": "anc_functions", "qualname": "squared_error", "kind": "function", "doc": "<p>Calculate the squared error.</p>\n\n<p>Args:\n    ys_orig (numpy.ndarray): original y values.\n    ys_line (numpy.ndarray): line y values.</p>\n\n<p>Returns:\n    float: the squared error.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ys_orig</span>, </span><span class=\"param\"><span class=\"n\">ys_line</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "anc_functions.coefficient_of_determination", "modulename": "anc_functions", "qualname": "coefficient_of_determination", "kind": "function", "doc": "<p>Calculate the coefficient of determination (R^2).</p>\n\n<p>Args:\n    ys_orig (numpy.ndarray): original y values.\n    ys_line (numpy.ndarray): line y values.</p>\n\n<p>Returns:\n    float: the coefficient of determination.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ys_orig</span>, </span><span class=\"param\"><span class=\"n\">ys_line</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "anc_functions.logistic_function", "modulename": "anc_functions", "qualname": "logistic_function", "kind": "function", "doc": "<p>Expression of the logistic function (numerically stable sigmoid function).</p>\n\n<p>Args:\n    phi (numpy array): Independent variable.\n    K (float): Carrying capacity.\n    psi (float): Growth rate.\n    alpha (float): Scaling parameter.</p>\n\n<p>Returns:\n    numpy array: Logistic function values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">phi</span>, </span><span class=\"param\"><span class=\"n\">K</span>, </span><span class=\"param\"><span class=\"n\">psi</span>, </span><span class=\"param\"><span class=\"n\">alpha</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "anc_functions.rmse", "modulename": "anc_functions", "qualname": "rmse", "kind": "function", "doc": "<p>Calculate the Root Mean Square Error (RMSE).</p>\n\n<p>Args:\n    predictions (numpy.ndarray): predicted values.\n    targets (numpy.ndarray): actual values.</p>\n\n<p>Returns:\n    float: the RMSE.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">predictions</span>, </span><span class=\"param\"><span class=\"n\">targets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model_curve_fit", "modulename": "model_curve_fit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "model_curve_fit.get_logistic_function_params", "modulename": "model_curve_fit", "qualname": "get_logistic_function_params", "kind": "function", "doc": "<p>This function calculates the parameters of the logistic function and saves them in csv files.</p>\n\n<p>Args:\n    log_output (str): The output string where the results of the logistic function will be saved.\n    mwt_output (str): The path to the output directory of the Mie scattering simulations.\n    smc_input (array_like): Array of soil moisture content values.</p>\n\n<p>Returns:\n    int: A value of 0 is returned after successful execution of the function.</p>\n\n<p>Notes:\n    This function assumes that the input directories contain specific csv files with parameters of\n    Modified (SWAP)-Hapke model. The function reads these csv files, performs calculations, fits the logistic function\n    to the soil moisture content data, and saves the parameters of the logistic function (K, psi, alpha)\n    and the coefficient of determination (r2) in separate csv files in the output directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">log_output</span>, </span><span class=\"param\"><span class=\"n\">mwt_output</span>, </span><span class=\"param\"><span class=\"n\">smc_input</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_inversion", "modulename": "hapke_inversion", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hapke_inversion.perform_inversion_dry", "modulename": "hapke_inversion", "qualname": "perform_inversion_dry", "kind": "function", "doc": "<p>Performs inversion on dry reflectance data.</p>\n\n<p>Args:\n    refl_dry (numpy.ndarray): Array of dry soil reflectance values.\n    solar_zenith (float): Solar zenith angle.\n    sensor_zenith (float): Sensor zenith angle.\n    sensor_azimuth (float): Sensor azimuth angle.\n    solar_azimuth (float): Solar azimuth angle.\n    wavelength (numpy.ndarray): Array of wavelengths.</p>\n\n<p>Returns:\n    tuple: Returns tuples of parameter arrays for w, B, b1, b2, b3, b4, fill, and C.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">refl_dry</span>,</span><span class=\"param\">\t<span class=\"n\">solar_zenith</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_zenith</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">solar_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">wavelength</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_inversion.perform_inversion_wet", "modulename": "hapke_inversion", "qualname": "perform_inversion_wet", "kind": "function", "doc": "<p>Performs inversion on wet reflectance data.</p>\n\n<p>Args:\n    refl_meas_wet (numpy.ndarray): Array of measured wet reflectance values.\n    solar_zenith (float): Solar zenith angle.\n    sensor_zenith (float): Sensor zenith angle.\n    sensor_azimuth (float): Sensor azimuth angle.\n    solar_azimuth (float): Solar azimuth angle.\n    wavelength (numpy.ndarray): Array of wavelengths.\n    alpha, w, B, b1, c1, b2, c2, fill, C (numpy arrays): Parameters for the Modified (SWAP)-Hapke model.</p>\n\n<p>Returns:\n    tuple: Returns tuples of parameter arrays for L and epsilon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">refl_meas_wet</span>,</span><span class=\"param\">\t<span class=\"n\">solar_zenith</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_zenith</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">solar_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">wavelength</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span>,</span><span class=\"param\">\t<span class=\"n\">w</span>,</span><span class=\"param\">\t<span class=\"n\">B</span>,</span><span class=\"param\">\t<span class=\"n\">b1</span>,</span><span class=\"param\">\t<span class=\"n\">b2</span>,</span><span class=\"param\">\t<span class=\"n\">b3</span>,</span><span class=\"param\">\t<span class=\"n\">b4</span>,</span><span class=\"param\">\t<span class=\"n\">fill</span>,</span><span class=\"param\">\t<span class=\"n\">C</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model", "modulename": "hapke_model", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hapke_model.calc_porosity_factor", "modulename": "hapke_model", "qualname": "calc_porosity_factor", "kind": "function", "doc": "<p>Calculate the porosity factor K for a given fill factor.</p>\n\n<p>Args:\n    fillFactor (float): The soil's fill factor.</p>\n\n<p>Returns:\n    float: The calculated porosity factor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fillFactor</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.hapke", "modulename": "hapke_model", "qualname": "hapke", "kind": "function", "doc": "<p>Calculate Hapke's 1% error H function using the IMSA Model.</p>\n\n<p>Args:\n    w (float): Single scattering albedo.\n    x (float): Angle (could be solar zenith or view zenith).\n    K (float): Porosity factor.</p>\n\n<p>Returns:\n    float: The calculated H function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">K</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.G1", "modulename": "hapke_model", "qualname": "G1", "kind": "function", "doc": "<p>Calculate g, based on solar zenith, view zenith, and relative azimuth.</p>\n\n<p>Args:\n    t_s (float): Solar zenith.\n    t_0 (float): View zenith.\n    sensor_azimuth (float): Sensor azimuth angle.\n    solar_azimuth (float): Solar azimuth angle.</p>\n\n<p>Returns:\n    float: The calculated g.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t_s</span>, </span><span class=\"param\"><span class=\"n\">t_0</span>, </span><span class=\"param\"><span class=\"n\">sensor_azimuth</span>, </span><span class=\"param\"><span class=\"n\">solar_azimuth</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.G2", "modulename": "hapke_model", "qualname": "G2", "kind": "function", "doc": "<p>Calculate g', based on solar zenith, view zenith, and relative azimuth.</p>\n\n<p>Args:\n    t_s (float): Solar zenith.\n    t_0 (float): View zenith.\n    sensor_azimuth (float): Sensor azimuth angle.\n    solar_azimuth (float): Solar azimuth angle.</p>\n\n<p>Returns:\n    float: The calculated g'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t_s</span>, </span><span class=\"param\"><span class=\"n\">t_0</span>, </span><span class=\"param\"><span class=\"n\">sensor_azimuth</span>, </span><span class=\"param\"><span class=\"n\">solar_azimuth</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.phase_function", "modulename": "hapke_model", "qualname": "phase_function", "kind": "function", "doc": "<p>Calculate the phase function based on solar zenith, view zenith, relative azimuth, and coefficients.</p>\n\n<p>Args:\n    b1, b2, b3, b4 (float): Coefficients for the phase function.\n    t_s (float): Solar zenith.\n    t_0 (float): View zenith.\n    sensor_azimuth (float): Sensor azimuth angle.\n    solar_azimuth (float): Solar azimuth angle.</p>\n\n<p>Returns:\n    float: The calculated phase function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b1</span>, </span><span class=\"param\"><span class=\"n\">b2</span>, </span><span class=\"param\"><span class=\"n\">b3</span>, </span><span class=\"param\"><span class=\"n\">b4</span>, </span><span class=\"param\"><span class=\"n\">t_s</span>, </span><span class=\"param\"><span class=\"n\">t_0</span>, </span><span class=\"param\"><span class=\"n\">sensor_azimuth</span>, </span><span class=\"param\"><span class=\"n\">solar_azimuth</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.B_g", "modulename": "hapke_model", "qualname": "B_g", "kind": "function", "doc": "<p>Calculates the SHOE function.</p>\n\n<p>Args:\n    B0 (float): Intensity size of the hot spot effect.\n    t_s (float): Solar zenith angle in degrees.\n    t_0 (float): Viewing zenith angle in degrees.\n    sensor_azimuth (float): Sensor azimuth angle in degrees.\n    solar_azimuth (float): Solar azimuth angle in degrees.\n    fillFactor (float): Porosity factor.\n    C (float): Parameter for SHOE function.</p>\n\n<p>Returns:\n    float: SHOE value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">B0</span>, </span><span class=\"param\"><span class=\"n\">t_s</span>, </span><span class=\"param\"><span class=\"n\">t_0</span>, </span><span class=\"param\"><span class=\"n\">sensor_azimuth</span>, </span><span class=\"param\"><span class=\"n\">solar_azimuth</span>, </span><span class=\"param\"><span class=\"n\">fillFactor</span>, </span><span class=\"param\"><span class=\"n\">C</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.k", "modulename": "hapke_model", "qualname": "k", "kind": "function", "doc": "<p>Calculates the K value for reflectance calculation.</p>\n\n<p>Args:\n    b1 (float): B coefficient.\n    c1 (float): C coefficient.\n    b2 (float): B' coefficient.\n    c2 (float): C' coefficient.\n    t_s (float): Solar zenith angle in degrees.\n    t_0 (float): Viewing zenith angle in degrees.\n    B0 (float): Intensity size of the hot spot effect.\n    sensor_azimuth (float): Sensor azimuth angle in degrees.\n    solar_azimuth (float): Solar azimuth angle in degrees.\n    fillFactor (float): Fill factor of the porous medium.\n    C (float): Parameter for SHOE function.</p>\n\n<p>Returns:\n    float: K value for reflectance calculation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b1</span>,</span><span class=\"param\">\t<span class=\"n\">b2</span>,</span><span class=\"param\">\t<span class=\"n\">b3</span>,</span><span class=\"param\">\t<span class=\"n\">b4</span>,</span><span class=\"param\">\t<span class=\"n\">t_s</span>,</span><span class=\"param\">\t<span class=\"n\">t_0</span>,</span><span class=\"param\">\t<span class=\"n\">B0</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">solar_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">fillFactor</span>,</span><span class=\"param\">\t<span class=\"n\">C</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.calc_refl", "modulename": "hapke_model", "qualname": "calc_refl", "kind": "function", "doc": "<p>Calculates the reflectance using the Modified (SWAP)-Hapke model.</p>\n\n<p>Args:\n    B0 (float): Intensity size of the hot spot effect.\n    t_s (float): Solar zenith angle in degrees.\n    t_0 (float): Viewing zenith angle in degrees.\n    sensor_azimuth (float): Sensor azimuth angle in degrees.\n    solar_azimuth (float): Solar azimuth angle in degrees.\n    w0 (float): Single scattering albedo.\n    b1 (float): B coefficient.\n    c1 (float): C coefficient.\n    b2 (float): B' coefficient.\n    c2 (float): C' coefficient.\n    fillFactor (float): Porosity factor.\n    C (float): Parameter for SHOE function.</p>\n\n<p>Returns:\n    float: Dry soil reflectance value using the Modified (SWAP)-Hapke model.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">B0</span>,</span><span class=\"param\">\t<span class=\"n\">t_s</span>,</span><span class=\"param\">\t<span class=\"n\">t_0</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">solar_azimuth</span>,</span><span class=\"param\">\t<span class=\"n\">w0</span>,</span><span class=\"param\">\t<span class=\"n\">b1</span>,</span><span class=\"param\">\t<span class=\"n\">b2</span>,</span><span class=\"param\">\t<span class=\"n\">b3</span>,</span><span class=\"param\">\t<span class=\"n\">b4</span>,</span><span class=\"param\">\t<span class=\"n\">fillFactor</span>,</span><span class=\"param\">\t<span class=\"n\">C</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hapke_model.calc_refl_2", "modulename": "hapke_model", "qualname": "calc_refl_2", "kind": "function", "doc": "<p>Calculates the final reflectance using the Modified (SWAP)-Hapke model.</p>\n\n<p>Args:\n    alpha (float): Absorption coefficient.\n    L (float): Equivalent water thickness.\n    r_hapke (float): Dry soil reflectance value using the Modified (SWAP)-Hapke model.\n    epsilon (float): Surface coverage fraction of water.</p>\n\n<p>Returns:\n    float: Wet soil reflectance value using the Modified (SWAP)-Hapke model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">alpha</span>, </span><span class=\"param\"><span class=\"n\">L</span>, </span><span class=\"param\"><span class=\"n\">r_dry</span>, </span><span class=\"param\"><span class=\"n\">epsilon</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model_save_output", "modulename": "model_save_output", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "model_save_output.get_curve_fit_data", "modulename": "model_save_output", "qualname": "get_curve_fit_data", "kind": "function", "doc": "<p>Extracts curve fitting data from provided file paths.</p>\n\n<p>This function reads data files from the input folder, sorts and aligns the data by\nrun numbers extracted from file names. It then computes mean water thickness and\nevaluates a logistic function with the mean water thickness and curve fitting parameters\nobtained from the input files. nrmse error between measured and estimated soil moisture\ncontent (smc) is then computed and sorted.</p>\n\n<p>Args:\n    inv_folder (str): Path to the input data folder.\n    smc_folder (str): Path to the folder containing soil moisture content data.\n    curve_K (str): Path to the file containing the 'K' values for the logistic function.\n    curve_psi (str): Path to the file containing the 'psi' values for the logistic function.\n    curve_alpha (str): Path to the file containing the 'alpha' values for the logistic function.\n    curve_r2 (str): Path to the file containing the 'r2' values for the logistic function.</p>\n\n<p>Returns:\n    tuple: A tuple containing arrays of mean water thickness, measured soil moisture content (smc),\n           estimated smc, nrmse error, 'r2' values, 'K' values, 'psi' values, 'alpha' values,\n           and sorted nrmse error indices.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inv_folder</span>, </span><span class=\"param\"><span class=\"n\">smc_folder</span>, </span><span class=\"param\"><span class=\"n\">curve_K</span>, </span><span class=\"param\"><span class=\"n\">curve_psi</span>, </span><span class=\"param\"><span class=\"n\">curve_alpha</span>, </span><span class=\"param\"><span class=\"n\">curve_r2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model_save_output.plot_rms", "modulename": "model_save_output", "qualname": "plot_rms", "kind": "function", "doc": "<p>This function plots the normalized root mean square error (NRMSE) for the given data.</p>\n\n<p>Args:\n    sensor_zenith_dry (np.array): Array of sensor zenith angles in dry conditions.\n    sensor_azimuth_dry (np.array): Array of sensor azimuth angles in dry conditions.\n    wavelength (np.array): Array of wavelengths.\n    rms (np.array): Array of normalized root mean square error (NRMSE) values.\n    img_output (str): The directory where the output image will be saved.</p>\n\n<p>Returns:\n    int: Returns 0 upon successful completion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sensor_zenith_dry</span>, </span><span class=\"param\"><span class=\"n\">sensor_azimuth_dry</span>, </span><span class=\"param\"><span class=\"n\">wavelength</span>, </span><span class=\"param\"><span class=\"n\">rms</span>, </span><span class=\"param\"><span class=\"n\">img_output</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model_save_output.plot_est_meas_smc", "modulename": "model_save_output", "qualname": "plot_est_meas_smc", "kind": "function", "doc": "<p>This function generates a plot of estimated versus measured soil moisture content (SMC).</p>\n\n<p>Args:\n    ind_val (int): Index value for selecting best nrmse indices.\n    rms_sort_ind (np.array): Array of sorted nrmse indices.\n    smc_est (np.array): Array of estimated soil moisture content (SMC).\n    smc_meas (np.array): Array of measured soil moisture content (SMC).\n    wavelength (np.array): Array of wavelengths.\n    sensor_zenith_dry (np.array): Array of sensor zenith angles in dry conditions.\n    sensor_azimuth_dry (np.array): Array of sensor azimuth angles in dry conditions.\n    img_output (str): The directory where the output image will be saved.</p>\n\n<p>Returns:\n    int: Returns 0 upon successful completion.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ind_val</span>,</span><span class=\"param\">\t<span class=\"n\">rms_sort_ind</span>,</span><span class=\"param\">\t<span class=\"n\">smc_est</span>,</span><span class=\"param\">\t<span class=\"n\">smc_meas</span>,</span><span class=\"param\">\t<span class=\"n\">wavelength</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_zenith_dry</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_azimuth_dry</span>,</span><span class=\"param\">\t<span class=\"n\">img_output</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model_save_output.plot_logistic_function", "modulename": "model_save_output", "qualname": "plot_logistic_function", "kind": "function", "doc": "<p>Plots the logistic function for soil moisture content against mean water thickness.</p>\n\n<p>Args:\n    ind_val (int): Index value in the sorted nrmse array.\n    rms_sort_ind (numpy array): Indices of the sorted nrmse array.\n    smc_est (numpy array): Array of estimated soil moisture content (SMC).\n    smc_meas (numpy array): Array of measured soil moisture content.\n    mean_water_thickness (numpy array): Array of mean water thickness.\n    K (numpy array): Array of values for the logistic function parameter K.\n    psi (numpy array): Array of values for the logistic function parameter psi.\n    alpha (numpy array): Array of values for the logistic function parameter alpha.\n    img_output (str): Path to save the plotted image.</p>\n\n<p>Returns:\n    int: 0 if the function executed successfully.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ind_val</span>,</span><span class=\"param\">\t<span class=\"n\">rms_sort_ind</span>,</span><span class=\"param\">\t<span class=\"n\">smc_est</span>,</span><span class=\"param\">\t<span class=\"n\">smc_meas</span>,</span><span class=\"param\">\t<span class=\"n\">mean_water_thickness</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">psi</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span>,</span><span class=\"param\">\t<span class=\"n\">img_output</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model_save_output.save_output_data", "modulename": "model_save_output", "qualname": "save_output_data", "kind": "function", "doc": "<p>Saves output data from model retrieval, including estimated and measured soil moisture content (SMC),\nthe logistic function parameters, and the best fit wavelength and angle.</p>\n\n<p>Args:\n    ind_val (int): Index value in the sorted nrmse array.\n    rms_sort_ind (numpy array): Indices of the sorted nrmse array.\n    smc_est (numpy array): Array of estimated soil moisture content (SMC).\n    smc_meas (numpy array): Array of measured soil moisture content.\n    wavelength (numpy array): Array of wavelength values.\n    sensor_zenith_dry (numpy array): Array of dry sensor zenith values.\n    sensor_azimuth_dry (numpy array): Array of dry sensor azimuth values.\n    K (numpy array): Array of values for the logistic function parameter K.\n    psi (numpy array): Array of values for the logistic function parameter psi.\n    alpha (numpy array): Array of values for the logistic function parameter alpha.\n    r2_val (numpy array): Array of r-squared values for model fit.\n    smc_output (str): Path to save the output data.</p>\n\n<p>Returns:\n    int: 0 if the function executed successfully.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ind_val</span>,</span><span class=\"param\">\t<span class=\"n\">rms_sort_ind</span>,</span><span class=\"param\">\t<span class=\"n\">smc_est</span>,</span><span class=\"param\">\t<span class=\"n\">smc_meas</span>,</span><span class=\"param\">\t<span class=\"n\">wavelength</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_zenith_dry</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_azimuth_dry</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">psi</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span>,</span><span class=\"param\">\t<span class=\"n\">r2_val</span>,</span><span class=\"param\">\t<span class=\"n\">smc_output</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_smc_refl", "modulename": "plot_smc_refl", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "plot_smc_refl.parse_csv_files_smc_plot", "modulename": "plot_smc_refl", "qualname": "parse_csv_files_smc_plot", "kind": "function", "doc": "<p>Parses a CSV file for plotting Soil Moisture Content (SMC).</p>\n\n<p>Args:\n    csv_file (str): Path to the CSV file to be parsed.</p>\n\n<p>Returns:\n    tuple: Contains soil moisture content data, reflectance data, and wavelength data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_smc_refl.spectral_lib_plot", "modulename": "plot_smc_refl", "qualname": "spectral_lib_plot", "kind": "function", "doc": "<p>Generates a spectral library plot.</p>\n\n<p>Args:\n    smc (numpy array): Soil moisture content data.\n    wavelength (numpy array): Wavelength data.\n    reflectance (numpy array): Reflectance data.\n    color_scheme (str): The color scheme for the plot.\n    xmin (int): The minimum x-axis value for the plot.\n    xmax (int): The maximum x-axis value for the plot.\n    img_output (str): Path to save the output image.</p>\n\n<p>Returns:\n    int: 0 if the function executed successfully.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">smc</span>, </span><span class=\"param\"><span class=\"n\">wavelength</span>, </span><span class=\"param\"><span class=\"n\">reflectance</span>, </span><span class=\"param\"><span class=\"n\">color_scheme</span>, </span><span class=\"param\"><span class=\"n\">xmin</span>, </span><span class=\"param\"><span class=\"n\">xmax</span>, </span><span class=\"param\"><span class=\"n\">img_output</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "read_var", "modulename": "read_var", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "read_var.parse_csv_files", "modulename": "read_var", "qualname": "parse_csv_files", "kind": "function", "doc": "<p>Parses a CSV file and extracts relevant data for calculations.</p>\n\n<p>Args:\n    csv_file (str): Path to the CSV file to be parsed.\n    solar_zenith_val (float): Value for solar zenith.\n    solar_azimuth_val (float): Value for solar azimuth.\n    azimuth_column (int): The column number where sensor azimuth data is located.\n    zenith_column (int): The column number where sensor zenith data is located.\n    start_wavelength_column (int): The column number where wavelength data starts.</p>\n\n<p>Returns:\n    tuple: Contains sensor azimuth data, sensor zenith data, solar zenith data, solar azimuth data, reflectance data, and wavelength data.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">csv_file</span>,</span><span class=\"param\">\t<span class=\"n\">solar_zenith_val</span>,</span><span class=\"param\">\t<span class=\"n\">solar_azimuth_val</span>,</span><span class=\"param\">\t<span class=\"n\">azimuth_column</span>,</span><span class=\"param\">\t<span class=\"n\">zenith_column</span>,</span><span class=\"param\">\t<span class=\"n\">start_wavelength_column</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "read_var.get_abs_nw", "modulename": "read_var", "qualname": "get_abs_nw", "kind": "function", "doc": "<p>Parses a CSV file and extracts absorption and non-water coefficients.</p>\n\n<p>Args:\n    csv_file (str): Path to the CSV file to be parsed.</p>\n\n<p>Returns:\n    tuple: Contains absorption coefficients and non-water coefficients.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();